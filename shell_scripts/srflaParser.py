# ----------------------------
# srfla parser.
#
# Odd combination of latex, locally defined latex macros,
# asciimath, and our own syntax.
#
# This is not mathematical typesetting, it is a language.
#
# Note: see http://www1.chapman.edu/~jipsen/mathml/asciimathsyntax.html
#
# TODO:
#
# 1. Update help
# 2. Documentation (symbol -> abbreviation)
# 3. Improve syntax (e.g., get rid of colons)
# 4. Get rid of eval, somehow.
# 5. Lazy/symbolic evaluation
#
# ----------------------------

# <<EOF>> and . omitted.

# ----------------------------
# constants and help messages
# ----------------------------

PROMPT_LENGTH = len('srfla > ')
HELP_MSG_NORMALIZE_LENGTH = 58

def msg_header(msg):
   return '* == ' + msg + ' ' + '=' * (HELP_MSG_NORMALIZE_LENGTH - len(msg))

def msg_direct(*opt):
   msg = '*\n* try \'help <flag ='
   for option in opt:
      msg = msg + ' ' + str(option)
   msg += r'''>' for further information'''
   return msg

INPUT_HELP_MSG = r'''*
*   Srfla accepts three input formats:
*        1. var <symbol> = <expression>;
*          eg: var a = 1;
*        2.  function <symbol> (<arguments>) : <expression>;
*          eg: function f() : "Number";
*              function isFruit(obj): obj \in fruit;
*        3.  eval <expression>;
*          eg: eval 3 + 2 * 5;
*   Symbol is defined as a letter followed by letters or digits.
*   Expressions are in the common expression format, and can be
* extended as expected.'''

TYPE_HELP_MSG = r'''*
*   Apart from number and string (begins and ends with double quote),
* record, tuple and set can also be defined under the following rules:
*        1. rec = [<symbol1> \mapsto <expression1>,  # no \n allowed
*                  <symbol2> \mapsto <expression2>, ...]
*          eg: eval [x \mapsto 1, y \mapsto 2];
*        2. tup = (<elem1>, <elem2>, ...)
*          eg: eval (1, 2, 3);
*        3. set = {<elem1>, <elem2>, ...}  # note: emptyset must only
*                                          # be typed in as \emptyset
*          eg: eval {1, 2, 3};'''

SPECIAL_OP_HELP_MSG = r'''*
*   Syntax for special operators:
*        1. forall / exists
*           <\forall / \exists>
*           <symbol1> \in <set1>, <symbol2> \in <set2> ...
*           <expression>
*          eg: eval \forall x \in {1, 2}: (x > 2);
*        2. getfield
*           There are two ways to get the field of a certain record.
*           1) a.x
*           2) a[x] or a["x"]
*           a.x and a["x"] are considered as the same. Both mean to get
*         to get the attribute named "x" in a. a[x] means to get the
*         attribute that has the same name as indicated by symbol x.
*          eg: var x = "y";
*              var a = [x \mapsto 1, y \mapsto 2];
*              eval a.x; ----> 1
*              eval a["x"] --> 1
*              eval a[x] ----> 2
*        3. set comprehension
*           The format for set comprehension is:
*           {<expression1> | <symbol1> in <set1>, <symbol2> in <set2> ...
*            : <expression2>}
*           The return value is a set generated by applying expression1 to
*         the set created by <symbol1> in <set1>, <symbol2> in <set2> ...
*         and filtered by expression2.
*          eg: {x + y | x \in {1, 2}, y \in {1, 2}: x < y} = {3}
*        4. lambda
*           Lambda function takes in args and returns the expression.
*         The format is \lambda (<symbol1>, <symbol2>, ..) <expression>
*          eg: var a = \lambda (a, b) a = b'''

SPECIAL_WORDS_HELP_MSG = r'''*
*   Backslash at the beginning of the word indicates that the word
* is reserved, and therefore, is expected to be among:
*   \T, \F, \times, \cdot, \ge, \emptyset, \cup, \cap, \backslash,
* \powerset, \ldots, \in, \subseteq, \supseteq, \subset, \supset,
* \vee, \implies, \bicond, \xor, \wedge, \neg, \forall, \exists,
* \relation, \to, \mapsto, \lambda
*   Any other words that begin with backslashes are not allowed.'''

RESERVED_WORDS_HELP_MSG = r'''*
*   Reserved words mostly begin with a backslash. The meaning or
* the usage and examples, if any, can be found at the right hand
* side of the arrows:
*        if, then, else, endif
*        \T  -----------> True
*        \F ------------> False
*        \times --------> set product
*                eg: {1, 3} \times {2} = {[1, 2], [3, 2]}
*        \cdot ---------> multiplication
*                eg: 3 \cdot 2 = 6
*        \ge -----------> greater than or equal to
*                eg: (3 \ge 2) = \T
*        \emptyset -----> emptyset
*        \cup ----------> set union
*                eg: ({1, 2, 3} \cup {2, 4}) = {1, 2, 3, 4}
*        \cap ----------> set intersection
*                eg: ({1, 2, 3} \cap {2, 4}) = {2}
*        \backslash ----> set difference
*                eg: ({1, 2} \backslash {2, 4}) = {1}
*                 # elements in {1, 2} that is not in {2, 4}
*        \powerset -----> powerset
*                eg: powerset({1, 2}) =
*                              {\emptyset, {1}, {2}, {1, 2}}
*        \ldots --------> range
*                eg: [1 \ldots 3] = [1..3] = {1, 2, 3}
*        \in -----------> in
*                eg: 1 \in {1} = \T
*        \subseteq -----> is subset or equals
*                eg: ({1, 3} \subseteq {1, 2, 3}) = \T
*        \supseteq -----> is supset or equals
*                eg: ({1, 3} \supseteq {1, 2, 3}) = \F
*        \subset -------> is proper subset
*                eg: ({1, 3} \subset {1, 3}) = \F
*        \supset -------> is proper supset
*                eg: ({1, 2, 3} \supset {1, 3}) = \T
*        \vee ----------> or
*        \implies ------> implies ('->')
*        \bicond -------> if and only if ('<->')
*        \xor ----------> xor
*        \wedge --------> and
*        \neg ----------> negation
*                eg: (neg \T) = \F
*        \forall -------> for all
*        \exists -------> exists
*        \relation, \to, \mapsto, \lambda'''

class TokenError(Exception):
   def __init__(self, token, msg = ""):
      self.msg = " " * (PROMPT_LENGTH + token.lexpos) + "^\nToken Error: Illegal token -- %s" % token.value
      if msg != "":
         self.msg += msg[1:]

class ProductionError(Exception):
   def __init__(self, production, msg = ""):
      if production is not None:
         self.msg = " " * (PROMPT_LENGTH + production.lexpos) + "^\nSyntax Error at %s" % production.value
      else:
         self.msg = "Syntax Error at the end of the line. \';\' might be missing"
      self.msg += msg

# ----------------------------
# setup lexer and parser
# ----------------------------

tokens = [
   'STRING', 'NUMBER', 'SYMBOL', 'SPECIAL'
]

# new operators: '*'
literals = [
   ':', '|', '(', ')', ',', ';', '/', '-', '^', '=', '<',
   '+', '>', '[', ']', '.', '{', '}'
]

reserved = {
   'help': 'HELP',
   'var': 'VAR',
   'function': 'FUNCTION',
   'eval': 'EVAL',
   'assume': 'ASSUME',
   'solve': 'SOLVE',
   'domain': 'DOMAIN',
   'codomain': 'CODOMAIN',
   'if': 'IF',
   'then': 'THEN',
   'else': 'ELSE',
   'endif': 'ENDIF',
   '\\T': 'SRFLATRUE',
   '\\F': 'SRFLAFALSE',
   '\\times': 'TIMES',
   '\\cdot': 'CDOT',
   '\\ge': 'GE',
   '\\le': 'LE',
   '\\ne': 'NE',
   '\\emptyset': 'EMPTYSET',
   '\\cup': 'CUP',
   '\\cap': 'CAP',
   '\\backslash' : 'BACKSLASH',
   '\\powerset': 'POWERSET',
   '\\ldots': 'LDOTS',
   '\\in': 'IN',
   '\\subseteq': 'SUBSETEQ',
   '\\supseteq': 'SUPSETEQ',
   '\\subset': 'SUBSET',
   '\\supset': 'SUPSET',
   '\\vee': 'VEE',
   '\\implies': 'IMPLIES',
   '\\bicond': 'BICOND',
   '\\xor': 'XOR',
   '\\wedge': 'WEDGE',
   '\\neg': 'NEG',
   '\\forall': 'FORALL',
   '\\exists': 'EXISTS',
   '\\relation': 'RELATION',
   '\\to': 'TO',
   '\\mapsto': 'MAPSTO',
   '\\lambda': 'LAMBDA',
   'unknown': 'UNKNOWN'
}

tokens += list(reserved.values())

# Tokens

# * or \cdot for multiplication
def t_CDOT(t):
    r'\*'
    t.value = '\\cdot'
    return t

# -> for implies
# FIXME: Should I go to double-array for implies and bicond?
def t_IMPLIES(t):
     r'->'
     t.value = '\\implies'
     return t

# <-> and iff for biconditional
def t_BICOND(t):
     r'iff'
     t.value = '\\bicond'
     return t

# and, ^^ for '\\wedge'
def t_WEDGE(t):
     r'\^\^|and'
     t.value = '\\wedge'
     return t

# or, vv for '\\vee'
def t_VEE(t):
     r'vv|or'
     t.value = '\\vee'
     return t

# o+ for XOR
def t_XOR(t):
     r'o\+'
     t.value = '\\xor'
     return t

# not equal
# FIXME: deal with \not =
def t_NE(t):
     r'!='
     t.value = '\\ne'
     return t

def t_LE(t):
     r'<='
     t.value = '\\le'
     return t

def t_GE(t):
     r'>='
     t.value = '\\ge'
     return t

def t_FORALL(t):
     r'AA'
     t.value = '\\forall'
     return t

def t_EXISTS(t):
     r'EE'
     t.value = '\\exists'
     return t

def t_NEG(t):
     r'not'
     t.value = '\\neg'
     return t

# FIXME: add !in, \not \in
def t_IN(t):
     r'in'
     t.value = '\\in'
     return t

def t_EMPTYSET(t):
     r'O/'
     t.value = '\\emptyset'
     return t

# FIXME: Syntax Error at NEXT symbol
def t_SUBSETEQ(t):
     r'sube'
     t.value = '\\subseteq'
     return t

def t_SUBSET(t):
     r'sub'
     t.value = '\\subset'
     return t

# FIXME: Syntax Error at NEXT symbol
def t_SUPSETEQ(t):
     r'supe'
     t.value = '\\supseteq'
     return t

def t_SUPSET(t):
     r'sup'
     t.value = '\\supset'
     return t

def t_CAP(t):
     r'nn'
     t.value = '\\cap'
     return t

def t_CUP(t):
     r'uu'
     t.value = '\\cup'
     return t

def t_TIMES(t):
     r'xx'
     t.value = '\\times'
     return t

def t_LDOTS(t):
    r'\.\.'
    t.value = '\\ldots'
    return t

t_ignore = ' \t'

def t_SPECIAL(t):
   r'\\[a-zA-Z]+'
   t.type = reserved.get(t.value, 'SPECIAL')
   if t.type == 'SPECIAL':
      raise TokenError(t, msg_direct('special'))
   return t

def t_SYMBOL(t):
   r'[a-zA-Z]([a-zA-Z0-9])*'
   t.type = reserved.get(t.value, 'SYMBOL')
   return t

def t_NUMBER(t):
   r'[0-9]+(\.[0-9]+)?\b'
   try:
      t.value = int(t.value)
   except ValueError:
      t.value = float(t.value)
   return t

def t_STRING(t):
   r'\"([^"\\]|(\\(.|\n)))*\"'
   t.value = t.value[1:-1]
   return t

def t_error(t):
   raise TokenError(t)

# Parsing rules

precedence = (
   ('left', 'LAMBDA'),
   ('nonassoc', 'PREC_RELATION'),
   ('nonassoc', 'IMPLIES'),
   ('nonassoc', 'QFORALL', 'QEXISTS'),
   ('left', 'BICOND', 'XOR'),
   ('left', 'VEE'),
   ('left', 'WEDGE'),
   ('left', 'NEG'),
   ('left', '<', '>', 'LE', 'GE', '=', 'NE'),
   ('left', 'SUBSETEQ', 'SUPSETEQ', 'SUBSET', 'SUPSET'),
   ('left', 'BACKSLASH'),
   ('left', 'CUP'),
   ('left', 'CAP'),
   ('left', 'TIMES'),
   ('left', 'IN'),
   ('left', 'PREC_LDOTS'),
   ('left', '+', '-'),
   ('left', 'CDOT', '/'),
   ('right', '^'),
   ('nonassoc', 'UMINUS'),
   ('left', '.'),
   ('left', 'PREC_GETFIELD', '['),
   ('nonassoc', 'PREC_FUNCTION_CALL', '('),
   ('nonassoc', 'PREC_HELP'),
   ('nonassoc', 'PREC_UNKNOWN')
)

# starting symbol
start = 'statement'

def p_statement_expr(p):
   """
   statement : VAR SYMBOL '=' expression ';'
             | FUNCTION SYMBOL arguments ':' expression ';'
             | EVAL expression ';'
             | ASSUME expression ';'
             | SOLVE symbol_list ';'
             | prompt
   """
   if p[1] == 'var':
      p[0] = ['var', p[2], p[4]]
   elif p[1] == 'function':
      p[0] = ['var', p[2], ['\\lambda', p[3], p[5]]]
   elif p[1] == 'eval':
      p[0] = p[2]
   elif p[1] == 'assume':
      p[0] = ['assume', p[2]]
   elif p[1] == 'solve':
      p[0] = ['solve', p[2]]

def p_prompt(p):
   """
   prompt : HELP %prec PREC_HELP
          | HELP SYMBOL
   """
   if len(p) == 2:
      print msg_header('HELP')
      print INPUT_HELP_MSG
      print msg_direct('type', 'operators', 'reserved')
      return
   if p[2] == 'type':
      print msg_header('TYPE')
      print TYPE_HELP_MSG
      return
   if p[2] == 'special':
      print msg_header('SPECIAL WORDS')
      print SPECIAL_WORDS_HELP_MSG
      return
   if p[2] == 'reserved':
      print msg_header('RESERVED WORDS')
      print RESERVED_WORDS_HELP_MSG
      return
   if p[2] == 'operators':
      print msg_header('SPECIAL OPERATORS')
      print SPECIAL_OP_HELP_MSG
      return
   print 'Illegal flag: ' + p[2]
   print 'try \'help\' with an optional flag again'
   print r'''flag must be among 'type', 'reserved', 'operators', 'special'.'''

def p_expression_cardinality(p):
   """
   expression : '|' expression '|'
   """
   p[0] = ['\\cardinality', p[2]]

def p_expression_ldot(p):
   """
   expression : '[' expression LDOTS expression ']' %prec PREC_LDOTS
   """
   p[0] = [p[3], p[2], p[4]]

def p_expression_powerset(p):
   """
   expression : POWERSET '(' expression ')'
   """
   p[0] = ['\powset', p[3]]

def p_expression_const(p):
   """
   expression : SRFLATRUE
              | SRFLAFALSE
              | EMPTYSET
   """
   if p[1] != '\\emptyset':
      p[0] = [p[1]]
   else:
      p[0] = ['Set']

def p_expression_basic_number(p):
   """
   expression : NUMBER
   """
   p[0] = ['Number', p[1]]

def p_expression_basic_symbol(p):
   """
   expression : SYMBOL
   """
   p[0] = ['Symbol', p[1]]

def p_expression_basic_string(p):
   """
   expression : STRING
   """
   p[0] = ['String', p[1]]

def p_expression_unknown(p):
   """
   expression : UNKNOWN expression %prec PREC_UNKNOWN
   """
   p[0] = ['unknown', p[2]]

def p_expression_parenthesis(p):
   """
   expression : '(' expression ')'
   """
   p[0] = p[2]

def p_expression_comprehension(p):
   """
   expression : '{' expression '|' vardecllist ':' expression '}'
   """
   p[0] = ['comprehension', p[2], p[4], p[6]]

def p_expression_quantifier(p):
   """
   expression : FORALL vardecllist ':' expression %prec QFORALL
              | EXISTS vardecllist ':' expression %prec QEXISTS
   """
   p[0] = [p[1], p[2], p[4]]

def p_expression_relation(p):
   """
   expression : RELATION expression TO expression ':' expression %prec PREC_RELATION
   """
   p[0] = [p[1], p[2], p[4], p[6]]

def p_expression_set(p):
   """
   expression : '{' exprlist '}'
   """
   p[0] = ['Set'] + p[2]

def p_expression_getfield_dot(p):
   """
   expression : expression '.' expression
   """
   if p[3][0] != 'Symbol':
      raise Error
   p[3][0] = 'String'
   p[0] = ['getfield', p[1], p[3]]

def p_expression_getfield_bracket(p):
   """
   expression : expression '[' expression ']' %prec PREC_GETFIELD
   """
   p[0] = ['getfield', p[1], p[3]]

def p_expression_record(p):
   """
   expression : '[' recorddecllist ']'
   """
   p[0] = ['recordfields'] + p[2]

def p_expression_tuple(p):
   """
   expression : '(' tupleexprlist ')'
   """
   p[0] = ['Tuple'] + p[2]

def p_expression_call_arguments(p):
   """
   expression : expression '(' exprlist ')' %prec PREC_FUNCTION_CALL
   """
   p[0] = ['call', p[1]] + p[3]

def p_expression_call_none(p):
   """
   expression : expression '(' ')' %prec PREC_FUNCTION_CALL
   """
   p[0] = ['call', p[1]]

def p_expression_bin_op(p):
   """
   expression : expression VEE expression
              | expression IMPLIES expression
              | expression BICOND expression
              | expression XOR expression
              | expression WEDGE expression
              | expression LE expression
              | expression GE expression
              | expression '<' expression
              | expression '=' expression
              | expression '>' expression
              | expression '+' expression
              | expression '-' expression
              | expression CDOT expression
              | expression '/' expression
              | expression '^' expression
              | expression CUP expression
              | expression CAP expression
              | expression BACKSLASH expression
              | expression TIMES expression
              | expression IN expression
              | expression SUBSETEQ expression
              | expression SUPSETEQ expression
              | expression SUBSET expression
              | expression SUPSET expression
   """
   p[0] = [p[2], p[1], p[3]]

def p_expression_not_equal(p):
   """
   expression : expression NE expression
   """
   p[0] = ['\\neg', ['=', p[1], p[3]]]

def p_expression_if(p):
   """
   expression : IF expression THEN expression ELSE expression ENDIF
              | IF expression THEN expression ENDIF
   """
   if len(p) != 8:
      raise Error
   p[0] = ['ite', p[2], p[4], p[6]]

def p_expression_neg(p):
   """
   expression : NEG expression
              | '-' expression %prec UMINUS
   """
   p[0] = [p[1], p[2]]

def p_lambda(p):
   """
   expression : LAMBDA arguments expression %prec LAMBDA
   """
   p[0] = [p[1], p[2], p[3]]

def p_arguments(p):
   """
   arguments : '(' symbol_list ')'
             | '(' ')'
   """
   if len(p) == 4:
      p[0] = ['args'] + p[2]
   else:
      p[0] = ['args']

def p_symbol_list(p):
   """
   symbol_list : SYMBOL
               | symbol_list ',' SYMBOL
   """
   if len(p) == 4:
      p[0] = p[1] + [p[3]]
   else:
      p[0] = [p[1]]

def p_vardecllist(p):
   """
   vardecllist : vardecl
               | vardecllist ',' vardecl
   """
   if len(p) == 4:
      p[0] = p[1] + [p[3]]
   else:
      p[0] = ['vardecllist', p[1]]

def p_vardecl(p):
   """
   vardecl : SYMBOL IN expression
           | SYMBOL
   """
   if len(p) == 4:
      p[0] = ['vardecl', ['Symbol', p[1]], p[3]]
   else:
      p[0] = ['vardecl', ['Symbol', p[1]], ['Symbol', 'world']]

def p_exprlist(p):
   """
   exprlist : expression
            | exprlist ',' expression
   """
   if len(p) == 2:
      p[0] = [p[1]]
   else:
      p[0] = p[1] + [p[3]]

def p_tupleexprlist_start(p):
   """
   tupleexprlist : expression ',' expression
   """
   p[0] = [p[1], p[3]]

def p_tupleexprlist_expand(p):
   """
   tupleexprlist : tupleexprlist ',' expression
   """
   p[0] = p[1] + [p[3]]

def p_recorddecllist(p):
   """
   recorddecllist : recorddecl
                  | recorddecllist ',' recorddecl
   """
   if len(p) == 2:
      p[0] = [p[1]]
   else:
      p[0] = p[1] + [p[3]]

def p_recorddecl(p):
   """
   recorddecl : SYMBOL MAPSTO expression
   """
   p[0] = [p[2], p[1], p[3]]

def p_error(p):
   raise ProductionError(p)

def srflaParser_init(path):
   import os
   import sys
   global lex
   import ply.lex as lex
   global yacc
   import ply.yacc as yacc
   lex.lex() # Build the lexer
   yacc.yacc(debug = 0, write_tables = 0)

if __name__ == '__main__':
   import os
   path = os.path.dirname(__file__)
   srflaParser_init(path)
   while True:
      try:
         s = raw_input('srfla > ')
      except EOFError:
         break
      try:
         output = yacc.parse(s)
      except TokenError as t_e:
         print t_e.msg
         continue
      except ProductionError as p_e:
         print p_e.msg
         continue
      if output is not None:
         print output

def srfla_parse(s):
   try:
      output = yacc.parse(s)
   except TokenError as t_e:
      return [0, t_e.msg]
   except ProductionError as p_e:
      return [-1, p_e.msg]
   return [1, output]
